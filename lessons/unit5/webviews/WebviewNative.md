# WKWebView and Native Interaction

## References

### Learn to be a web developer in 6 links

> AC 3.1 eat your hearts out

1. http://www.w3schools.com/html/html_intro.asp
1. http://www.w3schools.com/html/html_styles.asp
1. http://www.w3schools.com/html/html_css.asp
1. http://www.w3schools.com/html/html_classes.asp
1. http://www.w3schools.com/css/default.asp
1. http://www.w3schools.com/js/js_intro.asp

### WKWebView

1. https://developer.apple.com/reference/webkit/wkscriptmessagehandler
1. https://developer.apple.com/reference/webkit/wknavigationdelegate, specifically [```webView(_:decidePolicyFor:decisionHandler:)```](https://developer.apple.com/reference/webkit/wknavigationdelegate/1455641-webview)
1. [WKWebKit - NSHipster](http://nshipster.com/wkwebkit/), specifically the JavaScript ↔︎ Swift Communication bit.

## Lesson

### Why communicate? What's the point?

What are the motivations to communicate between your app and a Webview it contains? Here are a few:

* alter content (you probably don't control the URL)
* block links (you probably don't control the URL)
* hybrid apps (you probably have some control over the URL)

### Some thoughts about what's going on

Remember that there's entirely independent application running inside the WebView. It's loaded
some HTML and Javascript and that gets running. There is a wide range of complexity to web pages.
Consider a relatively static page like a Wikipedia page as compared to a Gmail inbox. The former
is assempled mostly on the server and just dumped into the browser as HTML to display. The latter
is a complex application heavily dependent upon Javascript.

Web programming is more layered than iOS, in that code is generated by otehr code. A common sequence
of stages might be:

```
(PHP/Java/Python) -> HTML -> CSS -> JS
```

A server side language generates a base HTML page, it loads in CSS which is a set of rules about
styling and then Javascript runs on top of that. The Javascript can alter things at the time of
loading or afterward, possibly making new network requests for an already-loaded page (AJAX).

DOM - Document Object Model. HTML is a tree of nodes.
Swift making JS that's manipulating HTML or the DOM, really.
DOM is a good tree response in an interview question. Tree representation.

**Mobile**

The form factor of a mobile device (small and hi res) has resulting in something called
responsive design. This means the styles on the page respond to this size and alter the content,
in the simplest/simplistic terms, bumping up font sizes and making things more vertical.

Since we're already way too deep into this I just grabbed the first reasonable-looking mobile
styles from http://getskeleton.com/. 

**Glue**

So what *is* going on? What's our role? If you find yourself writing this kind of code 
you're probably on a team that's got an able web team. As iOS developer you'd be focusing
on writing this kind of glue code, not the particulars of the display within the Webview.

### Executing Javascript from Swift

There are two ways to do this. One is by "injection", which happens exactly once on page load,
either at the beginning or the end, and the other is to run arbitrary Javascript
in the WebView on demand. This can be triggered any number of times.

#### Injection

```swift
let webConfiguration = WKWebViewConfiguration()
let userContentController = WKUserContentController()

let source = "document.body.style.background = \"#40c\";" // purplish
let userScript = WKUserScript(source: source, injectionTime: .atDocumentEnd, forMainFrameOnly: true)

userContentController.addUserScript(userScript)
webConfiguration.userContentController = userContentController
webView = WKWebView(frame: .zero, configuration: webConfiguration)
```

#### On demand

```swift
js += "document.getElementById('box1').innerHTML = 'red'"
webView.evaluateJavaScript(js) { (stuff, error) in
    print(stuff ?? "whoops")
}
```

### Executing Swift from Javascript

First add the handler:

```swift
let webConfiguration = WKWebViewConfiguration()
let userContentController = WKUserContentController()

// self conforms to protocol WKScriptMessageHandler
userContentController.add(self, name: "doEeet")

webConfiguration.userContentController = userContentController
webView = WKWebView(frame: .zero, configuration: webConfiguration)
```

Then catch messages:

```swift
func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
    print("Received message named: \(message.name)")
    print(message.body)
    
    if let msg = message.body as? [String:Any] {
        print(msg["msg"] ?? "whoops")
    }
}
```

### Debugging

You can configure your testing environment so that you can debug the WKWebView(s) in your app
interactively in desktop Safari. Definitely some magic going on there. Follow this guide:

https://developer.apple.com/library/content/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/GettingStarted/GettingStarted.html

You don't need to do this:

```
defaults write com.bundle.identifier WebKitDeveloperExtras -bool true
```


It is for Mac apps. 

**NB: I found that after following these instructions, I had to restart Safari and "Reset Content and Settings" in 
the Simulator.**


## Exercises:
1. Add a Text Field and send its content to a div in the WebView.
1. Write the "the cloud" to "my butt" (or similar) filter 


## Homework

I've cleaned up the MobyDick project a bit, leaving the web view and the segmented control. I've also 
set up an injected script, ```inject.js```. This script will be added to the end of all pages loaded into
the webview, giving you access to any functions you define in there.

1. Fork and clone.
1. Fix/change the Segmented control to alter the document background. In the Swift code
	it is still coded to connect to the "div boxes" which have now been removed. Alter it to work
	with the background.
1. Add a back button. You'll need to conform to ```WKNavigationDelegate``` and set ```self``` as the
	navigationDelegate.
1. Add a reload button. This has the same requirements as the previous step but you have that covered now.
1. Create a replacement feature. Add two ```UITextField```s and a button in the area below the webview. 
	The first text field should hold the value of text you want to change and the second the text you want 
	to change to. E.g. replace "water" with "fire". Once you get this working and you replace stuff you 
	can start all over again by hitting your reload button from the previous step.
1. Change the postProcess() Javascript function in ```inject.js``` to replace graphically inspiring
	words to images.
	You can google these and find small ones so they fit inline (enough) and you can
	look up how to fix the size of an image in its tag. Additionally/alternatively you can replace
	text with emoji.

	Here's an image tag.

	```
	<img src="https://somewhere.com/path/to/image.png" /> 
	```

	This will happen automatically when the page loads, not by any button pressing. 
	**Remember** to use the existing code in that function as a guide. And don't worry if 
	it looks totally awful. The replacement is the goal.

**ALSO**: Part of what I did was include [jQuery](http://jquery.com) a powerful library for modifying an HTML
DOM using Javascript. You can do a lot with it if you feel like playing with it, but I've made a point of
including enough Javascript inside the project as reference to complete it.
